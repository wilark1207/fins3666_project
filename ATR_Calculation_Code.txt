import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

SPY_intraday_df = pd.read_csv(
    "SPY_intraday_cleaned_FINAL.csv",
    parse_dates=['timestamp_utc'], # ensures timestamp column is datetime
)

########################################################################################################################
# Placeholder for probability time-series (output of CNN LSTM)
SPY_intraday_df['target'] = 0.502417088


########################################################################################################################

SPY_intraday_df.set_index('timestamp_utc', inplace=True)
SPY_intraday_df_5m = SPY_intraday_df.resample('5min').agg({
    'open': 'first',
    'high': 'max',
    'low': 'min',
    'close': 'last',
    'volume': 'sum',
    'ret': lambda x: (1 + x).prod() - 1,
    'target': 'last',
})
def calculate_risk_raw(df, price_col='close', ret_col='ret'):
    """
    Calculates basic risk measures.
    """
    risk = {}

    # Volatility: standard deviation of returns
    risk['volatility'] = df[ret_col].std()

    # Average True Range (ATR)
    high_low = df['high'] - df['low'] # calc high - low (minutely)
    high_close = np.abs(df['high'] - df[price_col].shift(1)) # calc high - prev close
    low_close = np.abs(df['low'] - df[price_col].shift(1)) # calc low - prev close
    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1) #.max to calc TRUE RANGE (largest price move)
    risk['ATR'] = tr.mean()

    return risk

# Example usage
risk_metrics = calculate_risk_raw(SPY_intraday_df_5m)
print(risk_metrics)

########################################################################################################################
# COMPUTE r_f
# risk_free_rate = risk_free_rate.sort_values('Effective date ')

full_index = pd.date_range(start='2022-11-07', end='2025-11-07', freq='D')
risk_free_rate = rf_raw.reindex(full_index).ffill()
risk_free_rate.index.name = 'date'

print(risk_free_rate.head(10))
print(risk_free_rate.tail(10))

start_backtest_date = '2025-09-01'
end_backtest_date = '2025-10-22'
rf_period = risk_free_rate.loc[start_backtest_date:end_backtest_date, 'Yield To Maturity']
avg_risk_free_rate = rf_period.mean()

def calculate_risk_and_return_metrics(
    df,
    avg_risk_free_rate,
    periods_per_year,
    benchmark_ret, # e.g., 252 for daily
    ret_col='ret', # CHANGE BACK TO 'ret'

):
    metrics = {}

    # Convert annualized RF to per-period
    rf_per_period = (1 + avg_risk_free_rate) ** (1 / periods_per_year) - 1

    # --- RISK MEASURES ---
    metrics['VaR_95'] = df[ret_col].quantile(0.05)
    metrics['CVaR_95'] = df[ret_col][df[ret_col] <= metrics['VaR_95']].mean()

    cumulative = (1 + df[ret_col]).cumprod()
    peak = cumulative.cummax()
    drawdown = (cumulative - peak) / peak
    metrics['Max_Drawdown'] = drawdown.min()

    # --- RISK-RETURN METRICS ---
    excess_ret = df[ret_col] - rf_per_period

    # Per-period Sharpe & Sortino
    sharpe_periodic = excess_ret.mean() / excess_ret.std() if excess_ret.std() != 0 else np.nan
    downside_std = df[ret_col][df[ret_col] < rf_per_period].std()
    sortino_periodic = excess_ret.mean() / downside_std if downside_std != 0 else np.nan

    # Annualize
    metrics['Sharpe'] = sharpe_periodic
    metrics['Sharpe_annualized'] = sharpe_periodic * np.sqrt(periods_per_year)
    metrics['Sortino'] = sortino_periodic
    metrics['Sortino_annualized'] = sortino_periodic * np.sqrt(periods_per_year)

    # Treynor & Information Ratio
    if benchmark_ret is not None:
        cov = np.cov(df[ret_col], benchmark_ret)[0, 1]
        beta = cov / np.var(benchmark_ret)
        metrics['Treynor'] = (df[ret_col].mean() - rf_per_period) / beta if beta != 0 else np.nan
        active_ret = df[ret_col] - benchmark_ret
        metrics['Information_Ratio'] = active_ret.mean() / active_ret.std() if active_ret.std() != 0 else np.nan

        metrics['Treynor_annualized'] = metrics['Treynor'] * periods_per_year
        metrics['Information_Ratio_annualized'] = metrics['Information_Ratio'] * np.sqrt(periods_per_year)
    else:
        metrics['Treynor'] = np.nan
        metrics['Information_Ratio'] = np.nan

    return metrics


minutes_per_year = 252 * 6.5 * 60
risk_metrics_raw = calculate_risk_and_return_metrics(SPY_intraday_df_5m, avg_risk_free_rate, minutes_per_year / 5, None) # div by 5 because 5min data used
print("Raw Data Risk Metrics:")
print(risk_metrics_raw)
